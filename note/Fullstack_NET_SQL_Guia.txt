Gu√≠a completa de Proyecto Fullstack (.NET + SQL Server)

=====================================
1. CREAR BASE DE DATOS EN SQL SERVER
=====================================

CREATE DATABASE DBFullstack;
GO
USE DBFullstack;
GO

CREATE TABLE Products (
    Id INT IDENTITY(1,1) PRIMARY KEY,
    Name NVARCHAR(100) NOT NULL,
    Price DECIMAL(10,2) NOT NULL,
    Stock INT NOT NULL,
    CreatedAt DATETIME DEFAULT GETDATE()
);
GO

INSERT INTO Products (Name, Price, Stock) VALUES
('Vaso de sangre', 210, 2),
('Brazo bi√≥nico', 3150, 4),
('M√°scara de piel humana', 55000, 3);
GO


=====================================
2. ESTRUCTURA DEL PROYECTO .NET 8
=====================================

FullstackSolution/
‚îÇ
‚îú‚îÄ‚îÄ Domain/
‚îÇ   ‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Product.cs
‚îÇ   ‚îî‚îÄ‚îÄ DTOs/
‚îÇ       ‚îî‚îÄ‚îÄ ProductCreateDto.cs
‚îÇ
‚îú‚îÄ‚îÄ Infrastructure/
‚îÇ   ‚îú‚îÄ‚îÄ Data/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AppDbContext.cs
‚îÇ   ‚îú‚îÄ‚îÄ Repositories/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IProductRepository.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProductRepository.cs
‚îÇ
‚îú‚îÄ‚îÄ Application/
‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IProductService.cs
‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îî‚îÄ‚îÄ ProductService.cs
‚îÇ
‚îî‚îÄ‚îÄ Fullstack.Api/
    ‚îú‚îÄ‚îÄ Controllers/
    ‚îÇ   ‚îî‚îÄ‚îÄ ProductController.cs
    ‚îú‚îÄ‚îÄ Program.cs
    ‚îú‚îÄ‚îÄ appsettings.json
    ‚îî‚îÄ‚îÄ Properties/
        ‚îî‚îÄ‚îÄ launchSettings.json


=====================================
3. INSTALACIONES NECESARIAS
=====================================

3.1 CREACI√ìN DE PROYECTOS

dotnet new webapi -n Fullstack.Api
dotnet new classlib -n Domain
dotnet new classlib -n Infrastructure
dotnet new classlib -n Application
dotnet new sln -n FullstackSolution

3.2 AGREGAR PROYECTOS A LA SOLUCI√ìN
dotnet sln add Domain/ Infrastructure/ Application/ Fullstack.Api/


3.3 AGREGAR REFERENCIAS ENTRE CAPAS

dotnet add Infrastructure reference Domain
dotnet add Application reference Infrastructure
dotnet add Application reference Domain
dotnet add Fullstack.Api reference Application
dotnet add Fullstack.Api reference Infrastructure
dotnet add Fullstack.Api reference Domain

3.4 DEPENDENCIAS NuGet (para EF Core y Swagger)

dotnet add Fullstack.Api reference Domain/ Infrastructure/ Application/

3.5 (Opcional pero √∫til) Confirmar configuraci√≥n

dotnet sln list

dotnet sln add Domain/Domain.csproj
dotnet sln add Infrastructure/Infrastructure.csproj
dotnet sln add Application/Application.csproj
dotnet sln add Fullstack.Api/Fullstack.Api.csproj

dotnet list Infrastructure reference
dotnet list Application reference
dotnet list Fullstack.Api reference


3.6 cd D:\POO\api\FullstackSolution\Infrastructure con la versi√≥n 8.0.10

dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools

3.7 Dentro del proyecto Fullstack.Api

cd ..\Fullstack.Api

dotnet add package Swashbuckle.AspNetCore
(Aunque esa parte ya se realizo)
dotnet add reference ..\Infrastructure
dotnet add reference ..\Application
dotnet add reference ..\Domain

3.8 Dentro del proyecto Application
cd ..\Application
dotnet add reference ..\Domain
dotnet add reference ..\Infrastructure


l proyecto que debes establecer como inicio es Fullstack.Api
cd 
=====================================
4. APPSETTINGS.JSON
=====================================

{
  "ConnectionStrings": {
    "DefaultConnection": "Server=ALANIS;Database=DBFullstack;Trusted_Connection=True;TrustServerCertificate=True;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}


=====================================
5. CLASES PRINCIPALES
=====================================

Product.cs
----------
namespace Domain.Entities;
public class Product {
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public int Stock { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.Now;
}

ProductCreateDto.cs
-------------------
namespace Domain.DTOs;
public class ProductCreateDto {
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public int Stock { get; set; }
}


=====================================
6. EF CORE CONTEXTO
=====================================

using Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Data;
public class AppDbContext : DbContext {
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
    public DbSet<Product> Products => Set<Product>();
}


=====================================
7. REPOSITORIO E INTERFAZ
=====================================

IProductRepository.cs
---------------------
using Domain.Entities;
namespace Infrastructure.Repositories;
public interface IProductRepository {
    Task<IEnumerable<Product>> GetAllAsync();
    Task<Product?> GetByIdAsync(int id);
    Task<Product> AddAsync(Product product);
    Task UpdateAsync(Product product);
    Task DeleteAsync(int id);
}

ProductRepository.cs
--------------------
using Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Repositories;
public class ProductRepository : IProductRepository {
    private readonly AppDbContext _context;
    public ProductRepository(AppDbContext context) => _context = context;

    public async Task<IEnumerable<Product>> GetAllAsync() => await _context.Products.ToListAsync();
    public async Task<Product?> GetByIdAsync(int id) => await _context.Products.FindAsync(id);
    public async Task<Product> AddAsync(Product product) {
        _context.Products.Add(product);
        await _context.SaveChangesAsync();
        return product;
    }
    public async Task UpdateAsync(Product product) {
        _context.Entry(product).State = EntityState.Modified;
        await _context.SaveChangesAsync();
    }
    public async Task DeleteAsync(int id) {
        var product = await _context.Products.FindAsync(id);
        if (product != null) {
            _context.Products.Remove(product);
            await _context.SaveChangesAsync();
        }
    }
}


=====================================
8. SERVICIO DE APLICACI√ìN
=====================================

IProductService.cs
------------------
using Domain.Entities;
using Domain.DTOs;

namespace Application.Interfaces;
public interface IProductService {
    Task<IEnumerable<Product>> GetAllAsync();
    Task<Product?> GetByIdAsync(int id);
    Task<Product> AddAsync(ProductCreateDto dto);
    Task UpdateAsync(int id, ProductCreateDto dto);
    Task DeleteAsync(int id);
}

ProductService.cs
-----------------
using Application.Interfaces;
using Domain.DTOs;
using Domain.Entities;
using Infrastructure.Repositories;

namespace Application.Services;
public class ProductService : IProductService {
    private readonly IProductRepository _repo;
    public ProductService(IProductRepository repo) => _repo = repo;

    public Task<IEnumerable<Product>> GetAllAsync() => _repo.GetAllAsync();
    public Task<Product?> GetByIdAsync(int id) => _repo.GetByIdAsync(id);

    public async Task<Product> AddAsync(ProductCreateDto dto) {
        var p = new Product { Name = dto.Name, Price = dto.Price, Stock = dto.Stock };
        return await _repo.AddAsync(p);
    }

    public async Task UpdateAsync(int id, ProductCreateDto dto) {
        var p = await _repo.GetByIdAsync(id);
        if (p == null) throw new Exception("No encontrado");
        p.Name = dto.Name;
        p.Price = dto.Price;
        p.Stock = dto.Stock;
        await _repo.UpdateAsync(p);
    }

    public Task DeleteAsync(int id) => _repo.DeleteAsync(id);
}


=====================================
9. CONTROLADOR Y PROGRAM.CS
=====================================

ProductController.cs
--------------------
using Application.Interfaces;
using Domain.DTOs;
using Microsoft.AspNetCore.Mvc;

namespace Fullstack.Api.Controllers;
[ApiController]
[Route("products")]
public class ProductController : ControllerBase {
    private readonly IProductService _service;
    public ProductController(IProductService service) => _service = service;

    [HttpGet]
    public async Task<IActionResult> GetAll() => Ok(await _service.GetAllAsync());

    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(int id) {
        var p = await _service.GetByIdAsync(id);
        return p is null ? NotFound() : Ok(p);
    }

    [HttpPost]
    public async Task<IActionResult> Create(ProductCreateDto dto) =>
        Ok(await _service.AddAsync(dto));

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, ProductCreateDto dto) {
        await _service.UpdateAsync(id, dto);
        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete(int id) {
        await _service.DeleteAsync(id);
        return NoContent();
    }
}

Program.cs
----------
using Application.Interfaces;
using Application.Services;
using Infrastructure.Data;
using Infrastructure.Repositories;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// EF Core con SQL Server
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// Inyecci√≥n de dependencias
builder.Services.AddScoped<IProductRepository, ProductRepository>();
builder.Services.AddScoped<IProductService, ProductService>();

// CORS (para el front)
builder.Services.AddCors(opt =>
{
    opt.AddPolicy("web", p => p
        .WithOrigins("http://localhost:5173")
        .AllowAnyHeader()
        .AllowAnyMethod());
});

// üî• ESTA L√çNEA FALTABA
builder.Services.AddControllers();

// Swagger
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

app.UseCors("web");

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// Mapea controladores
app.MapControllers();

app.Run();



=====================================
10. PRUEBA FINAL
=====================================

1. Ejecutar SQL Server y verificar la DB.
2. En Visual Studio: F5 o dotnet run.
3. Abrir https://localhost:7153/swagger/index.html
4. Probar los endpoints.
5. Conectar front en React en http://localhost:5173/


========================================
Pruebas Unitarias con xunit y Moq
=======================================

2.1 Creaci√≥n del proyecto de pruebas

Desde la ra√≠z de la soluci√≥n (FullstackSolution), se ejecutaron los siguientes comandos:

dotnet new xunit -n Fullstack.Tests
dotnet sln add Fullstack.Tests/Fullstack.Tests.csproj
dotnet add Fullstack.Tests reference Application/Application.csproj
dotnet add Fullstack.Tests reference Infrastructure/Infrastructure.csproj
dotnet add Fullstack.Tests reference Domain/Domain.csproj

2.2 Instalaci√≥n de dependencias

Dentro del proyecto Fullstack.Tests, se agregaron los siguientes paquetes NuGet:

dotnet add Fullstack.Tests package Moq
dotnet add Fullstack.Tests package Microsoft.EntityFrameworkCore.InMemory
dotnet add Fullstack.Tests package xunit.runner.visualstudio


Fullstack.Tests/
‚îÇ
‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îî‚îÄ‚îÄ ProductServiceTests.cs
‚îÇ
‚îî‚îÄ‚îÄ Repositories/
    ‚îî‚îÄ‚îÄ ProductRepositoryTests.cs


Services: contiene las pruebas enfocadas en la l√≥gica de negocio (Application).
Repositories: contiene las pruebas que validan el acceso a datos (Infrastructure).

4. Pruebas Unitarias del Servicio

Archivo: Services/ProductServiceTests.cs

Estas pruebas validan que la clase ProductService implemente correctamente las operaciones CRUD utilizando el repositorio inyectado.
Se utiliza Moq para simular el comportamiento del repositorio (IProductRepository).

using Application.Interfaces;
using Application.Services;
using Domain.DTOs;
using Domain.Entities;
using Infrastructure.Repositories;
using Moq;
using Xunit;

namespace Fullstack.Tests.Services;

public class ProductServiceTests
{
    [Fact]
    public async Task AddAsync_DeberiaCrearUnProductoCorrectamente()
    {
        // Arrange
        var mockRepo = new Mock<IProductRepository>();
        var service = new ProductService(mockRepo.Object);

        var dto = new ProductCreateDto
        {
            Name = "Brazo bi√≥nico",
            Price = 2500,
            Stock = 5
        };

        mockRepo
            .Setup(r => r.AddAsync(It.IsAny<Product>()))
            .ReturnsAsync((Product p) => p);

        // Act
        var result = await service.AddAsync(dto);

        // Assert
        Assert.Equal(dto.Name, result.Name);
        Assert.Equal(dto.Price, result.Price);
        Assert.Equal(dto.Stock, result.Stock);
    }

    [Fact]
    public async Task UpdateAsync_DeberiaLanzarExcepcion_SiNoExisteElProducto()
    {
        // Arrange
        var mockRepo = new Mock<IProductRepository>();
        var service = new ProductService(mockRepo.Object);

        mockRepo
            .Setup(r => r.GetByIdAsync(It.IsAny<int>()))
            .ReturnsAsync((Product?)null);

        var dto = new ProductCreateDto { Name = "No existe", Price = 100, Stock = 1 };

        // Act & Assert
        await Assert.ThrowsAsync<Exception>(() => service.UpdateAsync(99, dto));
    }
}

5. Pruebas Unitarias del Repositorio

Archivo: Repositories/ProductRepositoryTests.cs

Estas pruebas validan el comportamiento de ProductRepository mediante una base de datos en memoria usando Microsoft.EntityFrameworkCore.InMemory.
As√≠ se comprueba el funcionamiento de EF Core sin conectarse a SQL Server.


using Domain.Entities;
using Infrastructure.Data;
using Infrastructure.Repositories;
using Microsoft.EntityFrameworkCore;
using Xunit;

namespace Fullstack.Tests.Repositories;

public class ProductRepositoryTests
{
    private AppDbContext GetInMemoryDbContext()
    {
        var options = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
        return new AppDbContext(options);
    }

    [Fact]
    public async Task AddAsync_DeberiaAgregarUnProducto()
    {
        // Arrange
        var context = GetInMemoryDbContext();
        var repo = new ProductRepository(context);

        var product = new Product { Name = "Ojo bi√≥nico", Price = 5000, Stock = 2 };

        // Act
        var result = await repo.AddAsync(product);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(1, context.Products.Count());
    }

    [Fact]
    public async Task GetAllAsync_DeberiaRegresarListaDeProductos()
    {
        // Arrange
        var context = GetInMemoryDbContext();
        var repo = new ProductRepository(context);

        context.Products.AddRange(
            new Product { Name = "Chip neural", Price = 2000, Stock = 3 },
            new Product { Name = "Piel sint√©tica", Price = 1500, Stock = 10 }
        );
        await context.SaveChangesAsync();

        // Act
        var result = await repo.GetAllAsync();

        // Assert
        Assert.Equal(2, result.Count());
    }
}

6. Ejecuci√≥n de las Pruebas

Para ejecutar todas las pruebas del proyecto, se usa el comando:

dotnet test

Esto compila toda la soluci√≥n y muestra un resumen similar a:

Starting test execution, please wait...
Passed! 3 tests run in 330 ms

Correctas: 3  - Con error: 0  - Omitidas: 0  - Total: 3
Duraci√≥n: 350 ms - Fullstack.Tests.dll (net8.0)


Si se desea ejecutar solo un archivo o una prueba espec√≠fica:

dotnet test --filter "FullyQualifiedName~ProductServiceTests"

Beneficios de las Pruebas Unitarias

Evitan regresiones: permiten detectar fallos al modificar el c√≥digo.

Documentan el comportamiento esperado: cada prueba describe c√≥mo debe funcionar el sistema.

Aumentan la confianza en el c√≥digo: cada ‚ÄúPassed‚Äù es una garant√≠a de que la l√≥gica sigue funcionando.

Se integran con CI/CD: pueden ejecutarse autom√°ticamente en pipelines de GitHub Actions o Azure DevOps.






















